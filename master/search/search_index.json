{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Python OpenDota SDK","text":"\ud83e\udd16 AI Summary  Async Python SDK for OpenDota API. Use `OpenDota()` as async context manager. Key methods: `get_match(id)`, `get_player(id)`, `get_public_matches()`, `get_heroes()`. Returns Pydantic models by default (type-safe), or dicts with `format='json'`. Free tier: 2000 calls/day. Install: `pip install python-opendota-sdk`.   <p>Modern async Python wrapper for the OpenDota API</p> <p> </p> <p>A modern, async Python wrapper for the OpenDota API with full type safety and comprehensive coverage.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Async/await support - Built with <code>httpx</code> for modern async Python applications</li> <li>Type safety - Full type hints and Pydantic models for all API responses</li> <li>Comprehensive coverage - Support for matches, players, heroes, and more endpoints</li> <li>Rate limiting aware - Handles API rate limits gracefully with proper error handling</li> <li>Simple API - Clean, intuitive interface following Python best practices</li> <li>Well tested - Comprehensive test suite with real API integration tests</li> <li>Python 3.9+ - Compatible with modern Python versions</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import asyncio\nfrom opendota import OpenDota\n\nasync def main():\n    async with OpenDota() as client:\n        # Get recent public matches\n        matches = await client.get_public_matches()\n        print(f\"Found {len(matches)} recent matches\")\n\n        # Get detailed match data\n        match = await client.get_match(matches[0].match_id)\n        print(f\"Match duration: {match.duration // 60}m\")\n\n        # Get all heroes\n        heroes = await client.get_heroes()\n        print(f\"Total heroes: {len(heroes)}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install python-opendota-sdk\n</code></pre> <p>Or with uv:</p> <pre><code>uv add python-opendota-sdk\n</code></pre>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub Repository</li> <li>PyPI Package</li> <li>OpenDota API Docs</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"\ud83e\udd16 AI Summary  Version scheme: `{dota_major}.{dota_minor}.{dota_letter}.{sdk_release}` (e.g., 7.39.5.1 = Dota patch 7.39e, first SDK release). Current version adds: async httpx client, Pydantic models, matches/players/heroes/teams/leagues/pro_players endpoints, error handling, rate limiting, API key support, caching.   <p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#73951dev2-2025-12-03","title":"[7.39.5.1.dev2] - 2025-12-03","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Teams endpoints:</li> <li><code>get_teams()</code> - Get all teams sorted by rating</li> <li><code>get_team(team_id)</code> - Get team details</li> <li><code>get_team_players(team_id)</code> - Get team roster</li> <li><code>get_team_matches(team_id)</code> - Get team match history</li> <li>Pro Players endpoints:</li> <li><code>get_pro_players()</code> - Get all professional players</li> <li>Leagues endpoints:</li> <li><code>get_leagues()</code> - Get all leagues/tournaments</li> <li><code>get_league(league_id)</code> - Get league details</li> <li><code>get_league_matches(league_id)</code> - Get league matches</li> <li><code>get_league_teams(league_id)</code> - Get teams in a league</li> <li>New Pydantic models: <code>Team</code>, <code>TeamPlayer</code>, <code>TeamMatch</code>, <code>ProPlayer</code>, <code>League</code></li> <li>Comprehensive test suite for new endpoints</li> </ul>"},{"location":"changelog/#73951-2025-12-02","title":"[7.39.5.1] - 2025-12-02","text":"<p>Version scheme: <code>{dota_major}.{dota_minor}.{dota_letter}.{sdk_release}</code> - <code>7.39.5</code> = Dota 2 patch 7.39e (a=1, b=2, c=3, d=4, e=5) - <code>.1</code> = First SDK release for this patch</p>"},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Full async/await support with httpx</li> <li>Complete type safety with Pydantic models</li> <li>Matches endpoints:</li> <li><code>get_match()</code> - Get detailed match data</li> <li><code>get_public_matches()</code> - Get public matches with filters</li> <li><code>get_pro_matches()</code> - Get professional matches</li> <li><code>get_parsed_matches()</code> - Get parsed match data</li> <li>Players endpoints:</li> <li><code>get_player()</code> - Get player profile</li> <li><code>get_player_matches()</code> - Get player match history with extensive filtering</li> <li>Heroes endpoints:</li> <li><code>get_heroes()</code> - Get all heroes data</li> <li><code>get_hero_stats()</code> - Get hero statistics</li> <li>Comprehensive error handling with custom exceptions</li> <li>Rate limiting awareness and proper HTTP status handling</li> <li>Optional API key support for higher rate limits</li> <li>Context manager support for automatic cleanup</li> <li>Built-in response caching</li> <li>Extensive test suite with real API integration tests</li> <li>Full documentation with MkDocs Material theme</li> </ul>"},{"location":"changelog/#technical-details","title":"Technical Details","text":"<ul> <li>Python 3.9+ support</li> <li>Built with httpx for modern async HTTP</li> <li>Pydantic v2 for data validation and parsing</li> <li>Comprehensive type hints throughout</li> <li>CI/CD with GitHub Actions</li> <li>TestPyPI and PyPI publishing support</li> </ul>"},{"location":"examples/","title":"Examples","text":"\ud83e\udd16 AI Summary  Code examples for common tasks: **Match analysis** - get KDA, GPM, winner. **Player tracking** - profile, recent matches, winrate, most played heroes. **Meta heroes** - filter by pro pick rates, sort by win rate. **Player comparison** - compare stats between two players. **Pro match monitor** - poll for new pro matches. **Batch collection** - paginate through high MMR matches with rate limiting."},{"location":"examples/#analyze-match-performance","title":"Analyze Match Performance","text":"<pre><code>from opendota import OpenDota\n\nasync def analyze_match(match_id: int):\n    async with OpenDota() as client:\n        match = await client.get_match(match_id)\n\n        print(f\"Match {match_id} Analysis:\")\n        print(f\"Duration: {match.duration // 60}m {match.duration % 60}s\")\n        print(f\"Winner: {'Radiant' if match.radiant_win else 'Dire'}\")\n        print(f\"Score: {match.radiant_score} - {match.dire_score}\")\n\n        # Find MVP by KDA\n        best_kda = max(\n            match.players,\n            key=lambda p: (p.kills + p.assists) / max(p.deaths, 1)\n        )\n        team = \"Radiant\" if best_kda.player_slot &lt; 128 else \"Dire\"\n        print(f\"Best KDA: {best_kda.kills}/{best_kda.deaths}/{best_kda.assists} ({team})\")\n\n        # Team gold comparison\n        radiant_gpm = sum(p.gold_per_min for p in match.players if p.player_slot &lt; 128)\n        dire_gpm = sum(p.gold_per_min for p in match.players if p.player_slot &gt;= 128)\n        print(f\"Avg GPM - Radiant: {radiant_gpm/5:.0f}, Dire: {dire_gpm/5:.0f}\")\n</code></pre>"},{"location":"examples/#track-player-progress","title":"Track Player Progress","text":"<pre><code>from opendota import OpenDota\n\nasync def track_player(account_id: int):\n    async with OpenDota() as client:\n        # Get player profile\n        player = await client.get_player(account_id)\n        print(f\"Player: {player.profile.personaname}\")\n        print(f\"Rank: {player.rank_tier}\")\n\n        # Get recent matches\n        matches = await client.get_player_matches(account_id, limit=20)\n\n        wins = sum(1 for m in matches if (m.player_slot &lt; 128) == m.radiant_win)\n        total = len(matches)\n        winrate = wins / total * 100\n\n        avg_kills = sum(m.kills for m in matches) / total\n        avg_deaths = sum(m.deaths for m in matches) / total\n        avg_assists = sum(m.assists for m in matches) / total\n\n        print(f\"Last {total} matches:\")\n        print(f\"Winrate: {winrate:.1f}% ({wins}/{total})\")\n        print(f\"Avg KDA: {avg_kills:.1f}/{avg_deaths:.1f}/{avg_assists:.1f}\")\n\n        # Most played heroes\n        hero_counts = {}\n        for match in matches:\n            hero_counts[match.hero_id] = hero_counts.get(match.hero_id, 0) + 1\n\n        heroes = await client.get_heroes()\n        hero_names = {h.id: h.localized_name for h in heroes}\n\n        print(\"Most played heroes:\")\n        for hero_id, count in sorted(hero_counts.items(), key=lambda x: x[1], reverse=True)[:3]:\n            print(f\"  {hero_names.get(hero_id, 'Unknown')}: {count} games\")\n</code></pre>"},{"location":"examples/#find-meta-heroes","title":"Find Meta Heroes","text":"<pre><code>from opendota import OpenDota\n\nasync def find_meta_heroes():\n    async with OpenDota() as client:\n        hero_stats = await client.get_hero_stats()\n\n        # Filter heroes with significant pick rates\n        meta_heroes = [h for h in hero_stats if (h.pro_pick or 0) &gt; 50]\n\n        # Sort by win rate\n        meta_heroes.sort(\n            key=lambda h: (h.pro_win or 0) / max(h.pro_pick or 1, 1),\n            reverse=True\n        )\n\n        print(\"Current meta heroes (high pick + win rate):\")\n        for hero in meta_heroes[:10]:\n            if hero.pro_pick and hero.pro_win:\n                winrate = hero.pro_win / hero.pro_pick * 100\n                print(f\"{hero.localized_name}: {winrate:.1f}% WR ({hero.pro_pick} picks)\")\n</code></pre>"},{"location":"examples/#compare-two-players","title":"Compare Two Players","text":"<pre><code>from opendota import OpenDota\n\nasync def compare_players(player1_id: int, player2_id: int):\n    async with OpenDota() as client:\n        p1 = await client.get_player(player1_id)\n        p2 = await client.get_player(player2_id)\n\n        p1_matches = await client.get_player_matches(player1_id, limit=50)\n        p2_matches = await client.get_player_matches(player2_id, limit=50)\n\n        def calc_stats(matches):\n            wins = sum(1 for m in matches if (m.player_slot &lt; 128) == m.radiant_win)\n            avg_kda = sum(m.kills + m.assists for m in matches) / max(sum(m.deaths for m in matches), 1)\n            return {\"winrate\": wins / len(matches) * 100, \"kda\": avg_kda}\n\n        stats1 = calc_stats(p1_matches)\n        stats2 = calc_stats(p2_matches)\n\n        print(f\"Comparison: {p1.profile.personaname} vs {p2.profile.personaname}\")\n        print(f\"Winrate: {stats1['winrate']:.1f}% vs {stats2['winrate']:.1f}%\")\n        print(f\"Avg KDA: {stats1['kda']:.2f} vs {stats2['kda']:.2f}\")\n</code></pre>"},{"location":"examples/#pro-match-monitor","title":"Pro Match Monitor","text":"<pre><code>from opendota import OpenDota\nimport asyncio\n\nasync def monitor_pro_matches():\n    async with OpenDota() as client:\n        last_match_id = None\n\n        while True:\n            pro_matches = await client.get_pro_matches()\n\n            for match in pro_matches:\n                if last_match_id and match.match_id &lt;= last_match_id:\n                    break\n\n                if match.radiant_name and match.dire_name:\n                    winner = match.radiant_name if match.radiant_win else match.dire_name\n                    print(f\"[{match.league_name}] {match.radiant_name} vs {match.dire_name}\")\n                    print(f\"  Winner: {winner} ({match.duration // 60}m)\")\n\n            if pro_matches:\n                last_match_id = pro_matches[0].match_id\n\n            await asyncio.sleep(60)  # Check every minute\n</code></pre>"},{"location":"examples/#batch-data-collection","title":"Batch Data Collection","text":"<pre><code>from opendota import OpenDota\nimport asyncio\n\nasync def collect_high_mmr_matches(count: int = 100):\n    async with OpenDota() as client:\n        all_matches = []\n        last_match_id = None\n\n        while len(all_matches) &lt; count:\n            matches = await client.get_public_matches(\n                mmr_descending=6000,\n                less_than_match_id=last_match_id\n            )\n\n            if not matches:\n                break\n\n            all_matches.extend(matches)\n            last_match_id = matches[-1].match_id\n\n            # Respect rate limits\n            await asyncio.sleep(1)\n\n        print(f\"Collected {len(all_matches)} high MMR matches\")\n        return all_matches[:count]\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"\ud83e\udd16 AI Summary  Install: `pip install python-opendota-sdk` or `uv add python-opendota-sdk`. Use async context manager: `async with OpenDota() as client`. Optional API key via env var `OPENDOTA_API_KEY` or constructor param for unlimited calls. Two output formats: `format='pydantic'` (default, type-safe) or `format='json'` (raw dicts)."},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#from-pypi-recommended","title":"From PyPI (Recommended)","text":"<pre><code>pip install python-opendota-sdk\n</code></pre> <p>Or with uv:</p> <pre><code>uv add python-opendota-sdk\n</code></pre>"},{"location":"getting-started/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/DeepBlueCoding/python-opendota-sdk.git\ncd python-opendota-sdk\nuv sync\n</code></pre>"},{"location":"getting-started/#authentication","title":"Authentication","text":"<p>The OpenDota API supports optional API keys for higher rate limits.</p>"},{"location":"getting-started/#rate-limits","title":"Rate Limits","text":"Tier Daily Calls Per Minute Free 2,000 60 With API Key Unlimited Higher"},{"location":"getting-started/#setting-api-key","title":"Setting API Key","text":"<pre><code># Option 1: Environment variable\nimport os\nos.environ[\"OPENDOTA_API_KEY\"] = \"your-api-key\"\n\n# Option 2: Direct initialization\nfrom opendota import OpenDota\nclient = OpenDota(api_key=\"your-api-key\")\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#context-manager-recommended","title":"Context Manager (Recommended)","text":"<pre><code>from opendota import OpenDota\n\nasync with OpenDota() as client:\n    matches = await client.get_public_matches()\n    # Client automatically closed when exiting context\n</code></pre>"},{"location":"getting-started/#manual-management","title":"Manual Management","text":"<pre><code>from opendota import OpenDota\n\nclient = OpenDota()\ntry:\n    matches = await client.get_public_matches()\nfinally:\n    await client.close()\n</code></pre>"},{"location":"getting-started/#output-formats","title":"Output Formats","text":"<p>Choose between structured Pydantic models or raw JSON dictionaries:</p> <pre><code># Pydantic models (default) - Full type safety\nclient = OpenDota(format='pydantic')\nmatches = await client.get_public_matches()\nprint(matches[0].match_id)  # Type-safe access\n\n# JSON dictionaries - Direct API response\nclient = OpenDota(format='json')\nmatches = await client.get_public_matches()\nprint(matches[0]['match_id'])  # Dict access\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Check out the Examples for common use cases</li> <li>See the API Reference for all available methods</li> </ul>"},{"location":"api/client/","title":"Client Reference","text":"\ud83e\udd16 AI Summary  **OpenDota class constructor**: `api_key`, `timeout`, `format` ('pydantic'/'json'). **Match methods**: `get_match(id)`, `get_public_matches(mmr_ascending, less_than_match_id)`, `get_pro_matches()`. **Player methods**: `get_player(account_id)`, `get_player_matches(account_id, hero_id, limit, win)`. **Hero methods**: `get_heroes()`, `get_hero_stats()`. **Teams**: `get_teams()`, `get_team(id)`, `get_team_players(id)`, `get_team_matches(id)`. **Leagues**: `get_leagues()`, `get_league(id)`, `get_league_matches(id)`, `get_league_teams(id)`. **Pro Players**: `get_pro_players()`."},{"location":"api/client/#opendota-class","title":"OpenDota Class","text":"<p>The main client for interacting with the OpenDota API.</p> <pre><code>from opendota import OpenDota\n</code></pre>"},{"location":"api/client/#constructor","title":"Constructor","text":"<pre><code>OpenDota(\n    data_dir: Optional[str] = None,\n    api_key: Optional[str] = None,\n    delay: int = 3,\n    fantasy: Optional[Dict[str, float]] = None,\n    api_url: Optional[str] = None,\n    timeout: float = 30.0,\n    format: Literal['pydantic', 'json'] = 'pydantic',\n    auth_method: Literal['header', 'query'] = 'header'\n)\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>data_dir</code> <code>str</code> <code>~/dota2</code> Directory for caching API responses <code>api_key</code> <code>str</code> <code>None</code> OpenDota API key for higher rate limits <code>delay</code> <code>int</code> <code>3</code> Delay between requests (ignored with API key) <code>timeout</code> <code>float</code> <code>30.0</code> Request timeout in seconds <code>format</code> <code>str</code> <code>'pydantic'</code> Response format: <code>'pydantic'</code> or <code>'json'</code> <code>auth_method</code> <code>str</code> <code>'header'</code> Auth method: <code>'header'</code> or <code>'query'</code>"},{"location":"api/client/#match-methods","title":"Match Methods","text":""},{"location":"api/client/#get_match","title":"get_match","text":"<p>Get detailed match data by match ID.</p> <pre><code>match = await client.get_match(8461956309)\n</code></pre> <p>Parameters:</p> <ul> <li><code>match_id</code> (int): The match ID to retrieve</li> </ul> <p>Returns: <code>Match</code> model or dict</p>"},{"location":"api/client/#get_public_matches","title":"get_public_matches","text":"<p>Get recent public matches with optional filters.</p> <pre><code>matches = await client.get_public_matches(\n    mmr_ascending=4000,\n    less_than_match_id=8461956309\n)\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>mmr_ascending</code> <code>int</code> Return matches with avg MMR ascending from this <code>mmr_descending</code> <code>int</code> Return matches with avg MMR descending from this <code>less_than_match_id</code> <code>int</code> Return matches with ID lower than this <p>Returns: <code>List[PublicMatch]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#get_pro_matches","title":"get_pro_matches","text":"<p>Get professional matches.</p> <pre><code>pro_matches = await client.get_pro_matches()\n</code></pre> <p>Parameters:</p> <ul> <li><code>less_than_match_id</code> (int, optional): Return matches with ID lower than this</li> </ul> <p>Returns: <code>List[ProMatch]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#player-methods","title":"Player Methods","text":""},{"location":"api/client/#get_player","title":"get_player","text":"<p>Get player profile by account ID.</p> <pre><code>player = await client.get_player(70388657)\n</code></pre> <p>Parameters:</p> <ul> <li><code>account_id</code> (int): The player's account ID</li> </ul> <p>Returns: <code>PlayerProfile</code> model or dict</p>"},{"location":"api/client/#get_player_matches","title":"get_player_matches","text":"<p>Get matches for a player with extensive filtering.</p> <pre><code>matches = await client.get_player_matches(\n    account_id=70388657,\n    hero_id=14,  # Pudge\n    limit=10,\n    win=1  # Only wins\n)\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>account_id</code> <code>int</code> Player's account ID (required) <code>limit</code> <code>int</code> Number of matches to return <code>offset</code> <code>int</code> Number of matches to skip <code>win</code> <code>int</code> Filter by wins (0=loss, 1=win) <code>hero_id</code> <code>int</code> Filter by hero ID <code>game_mode</code> <code>int</code> Filter by game mode <code>lobby_type</code> <code>int</code> Filter by lobby type <code>date</code> <code>int</code> Filter by days since epoch <p>Returns: <code>List[PlayerMatch]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#hero-methods","title":"Hero Methods","text":""},{"location":"api/client/#get_heroes","title":"get_heroes","text":"<p>Get all heroes data.</p> <pre><code>heroes = await client.get_heroes()\n</code></pre> <p>Returns: <code>List[Hero]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#get_hero_stats","title":"get_hero_stats","text":"<p>Get hero statistics including pick/win rates.</p> <pre><code>hero_stats = await client.get_hero_stats()\n</code></pre> <p>Returns: <code>List[HeroStats]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#team-methods","title":"Team Methods","text":""},{"location":"api/client/#get_teams","title":"get_teams","text":"<p>Get all teams sorted by rating.</p> <pre><code>teams = await client.get_teams()\n</code></pre> <p>Returns: <code>List[Team]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#get_team","title":"get_team","text":"<p>Get team details by ID.</p> <pre><code>team = await client.get_team(8599101)  # Team Spirit\n</code></pre> <p>Parameters:</p> <ul> <li><code>team_id</code> (int): The team ID to retrieve</li> </ul> <p>Returns: <code>Team</code> model or dict</p>"},{"location":"api/client/#get_team_players","title":"get_team_players","text":"<p>Get team roster (current and past players).</p> <pre><code>players = await client.get_team_players(8599101)\n</code></pre> <p>Parameters:</p> <ul> <li><code>team_id</code> (int): The team ID</li> </ul> <p>Returns: <code>List[TeamPlayer]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#get_team_matches","title":"get_team_matches","text":"<p>Get team match history.</p> <pre><code>matches = await client.get_team_matches(8599101)\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>team_id</code> <code>int</code> The team ID (required) <code>limit</code> <code>int</code> Number of matches to return (optional) <p>Returns: <code>List[TeamMatch]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#league-methods","title":"League Methods","text":""},{"location":"api/client/#get_leagues","title":"get_leagues","text":"<p>Get all leagues/tournaments.</p> <pre><code>leagues = await client.get_leagues()\n</code></pre> <p>Returns: <code>List[League]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#get_league","title":"get_league","text":"<p>Get league details by ID.</p> <pre><code>league = await client.get_league(15728)  # The International\n</code></pre> <p>Parameters:</p> <ul> <li><code>league_id</code> (int): The league ID to retrieve</li> </ul> <p>Returns: <code>League</code> model or dict</p>"},{"location":"api/client/#get_league_matches","title":"get_league_matches","text":"<p>Get matches from a league.</p> <pre><code>matches = await client.get_league_matches(15728, limit=50)\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>league_id</code> <code>int</code> The league ID (required) <code>limit</code> <code>int</code> Number of matches to return (optional) <p>Returns: <code>List[LeagueMatch]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#get_league_teams","title":"get_league_teams","text":"<p>Get teams participating in a league.</p> <pre><code>teams = await client.get_league_teams(15728)\n</code></pre> <p>Parameters:</p> <ul> <li><code>league_id</code> (int): The league ID</li> </ul> <p>Returns: <code>List[LeagueTeam]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#pro-player-methods","title":"Pro Player Methods","text":""},{"location":"api/client/#get_pro_players","title":"get_pro_players","text":"<p>Get all professional players.</p> <pre><code>pro_players = await client.get_pro_players()\n</code></pre> <p>Returns: <code>List[ProPlayer]</code> or <code>List[dict]</code></p>"},{"location":"api/exceptions/","title":"Exceptions","text":"\ud83e\udd16 AI Summary  Exception hierarchy: `OpenDotaError` (base) \u2192 `OpenDotaAPIError` (has `status_code`) \u2192 `OpenDotaRateLimitError` (429), `OpenDotaNotFoundError` (404). Catch specific exceptions first, fallback to `OpenDotaAPIError`. For rate limits, implement exponential backoff retry (2^attempt seconds).   <p>Custom exceptions for handling API errors.</p>"},{"location":"api/exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>OpenDotaError (base)\n\u2514\u2500\u2500 OpenDotaAPIError\n    \u251c\u2500\u2500 OpenDotaRateLimitError\n    \u2514\u2500\u2500 OpenDotaNotFoundError\n</code></pre>"},{"location":"api/exceptions/#opendotaerror","title":"OpenDotaError","text":"<p>Base exception for all OpenDota SDK errors.</p> <pre><code>class OpenDotaError(Exception):\n    \"\"\"Base exception for OpenDota API errors.\"\"\"\n    pass\n</code></pre>"},{"location":"api/exceptions/#opendotaapierror","title":"OpenDotaAPIError","text":"<p>General API error with status code.</p> <pre><code>class OpenDotaAPIError(OpenDotaError):\n    def __init__(self, message: str, status_code: int):\n        self.status_code = status_code\n        super().__init__(message)\n</code></pre> <p>Attributes:</p> <ul> <li><code>status_code</code> (int): HTTP status code from the API</li> </ul>"},{"location":"api/exceptions/#opendotaratelimiterror","title":"OpenDotaRateLimitError","text":"<p>Raised when API rate limit is exceeded (HTTP 429).</p> <pre><code>class OpenDotaRateLimitError(OpenDotaAPIError):\n    \"\"\"Rate limit exceeded error.\"\"\"\n    pass\n</code></pre>"},{"location":"api/exceptions/#opendotanotfounderror","title":"OpenDotaNotFoundError","text":"<p>Raised when a resource is not found (HTTP 404).</p> <pre><code>class OpenDotaNotFoundError(OpenDotaAPIError):\n    \"\"\"Resource not found error.\"\"\"\n    pass\n</code></pre>"},{"location":"api/exceptions/#error-handling-example","title":"Error Handling Example","text":"<pre><code>from opendota import OpenDota\nfrom opendota.exceptions import (\n    OpenDotaAPIError,\n    OpenDotaNotFoundError,\n    OpenDotaRateLimitError\n)\n\nasync with OpenDota() as client:\n    try:\n        match = await client.get_match(invalid_match_id)\n    except OpenDotaNotFoundError:\n        print(\"Match not found\")\n    except OpenDotaRateLimitError:\n        print(\"Rate limit exceeded - wait before retrying\")\n    except OpenDotaAPIError as e:\n        print(f\"API error (status {e.status_code}): {e}\")\n</code></pre>"},{"location":"api/exceptions/#retry-strategy","title":"Retry Strategy","text":"<p>For rate limit errors, implement exponential backoff:</p> <pre><code>import asyncio\nfrom opendota.exceptions import OpenDotaRateLimitError\n\nasync def get_match_with_retry(client, match_id, max_retries=3):\n    for attempt in range(max_retries):\n        try:\n            return await client.get_match(match_id)\n        except OpenDotaRateLimitError:\n            if attempt &lt; max_retries - 1:\n                wait_time = 2 ** attempt  # 1, 2, 4 seconds\n                await asyncio.sleep(wait_time)\n            else:\n                raise\n</code></pre>"},{"location":"api/models/","title":"Data Models","text":"\ud83e\udd16 AI Summary  Pydantic models for API responses. **Match models**: `Match` (full data with players list), `PublicMatch` (summary with avg_mmr), `ProMatch` (with team/league names). **Player models**: `PlayerProfile` (profile + rank_tier), `PlayerMatch` (hero_id, KDA, player_slot). **Hero models**: `Hero` (name, roles, primary_attr), `HeroStats` (pro_pick/win/ban, rank-specific picks). Access via typed properties: `match.radiant_win`, `player.kills`.   <p>All API responses are parsed into Pydantic models with full type safety.</p>"},{"location":"api/models/#match-models","title":"Match Models","text":""},{"location":"api/models/#match","title":"Match","text":"<p>Detailed match data returned by <code>get_match()</code>.</p> <pre><code>class Match(BaseModel):\n    match_id: int\n    duration: int\n    radiant_win: bool\n    radiant_score: int\n    dire_score: int\n    players: List[MatchPlayer]\n    # ... and many more fields\n</code></pre> <p>Key Fields:</p> Field Type Description <code>match_id</code> <code>int</code> Unique match identifier <code>duration</code> <code>int</code> Match duration in seconds <code>radiant_win</code> <code>bool</code> Whether Radiant won <code>radiant_score</code> <code>int</code> Radiant kill score <code>dire_score</code> <code>int</code> Dire kill score <code>players</code> <code>List[MatchPlayer]</code> List of player data"},{"location":"api/models/#publicmatch","title":"PublicMatch","text":"<p>Summary data for public matches.</p> <pre><code>class PublicMatch(BaseModel):\n    match_id: int\n    duration: int\n    radiant_win: bool\n    avg_mmr: Optional[int]\n</code></pre>"},{"location":"api/models/#promatch","title":"ProMatch","text":"<p>Professional match data.</p> <pre><code>class ProMatch(BaseModel):\n    match_id: int\n    duration: int\n    radiant_win: bool\n    radiant_name: Optional[str]\n    dire_name: Optional[str]\n    league_name: Optional[str]\n</code></pre>"},{"location":"api/models/#player-models","title":"Player Models","text":""},{"location":"api/models/#playerprofile","title":"PlayerProfile","text":"<p>Player profile and ranking data.</p> <pre><code>class PlayerProfile(BaseModel):\n    profile: Profile\n    rank_tier: Optional[int]\n    leaderboard_rank: Optional[int]\n</code></pre> <p>Profile Sub-model:</p> <pre><code>class Profile(BaseModel):\n    account_id: int\n    personaname: str\n    name: Optional[str]\n    steamid: str\n    avatar: str\n    loccountrycode: Optional[str]\n</code></pre>"},{"location":"api/models/#playermatch","title":"PlayerMatch","text":"<p>Match data from player's perspective.</p> <pre><code>class PlayerMatch(BaseModel):\n    match_id: int\n    hero_id: int\n    kills: int\n    deaths: int\n    assists: int\n    player_slot: int\n    radiant_win: bool\n</code></pre>"},{"location":"api/models/#hero-models","title":"Hero Models","text":""},{"location":"api/models/#hero","title":"Hero","text":"<p>Basic hero information.</p> <pre><code>class Hero(BaseModel):\n    id: int\n    name: str\n    localized_name: str\n    primary_attr: str\n    attack_type: str\n    roles: List[str]\n</code></pre>"},{"location":"api/models/#herostats","title":"HeroStats","text":"<p>Hero statistics with pick/win rates.</p> <pre><code>class HeroStats(BaseModel):\n    id: int\n    localized_name: str\n    pro_pick: Optional[int]\n    pro_win: Optional[int]\n    pro_ban: Optional[int]\n    # Per-rank pick rates\n    herald_picks: Optional[int]\n    guardian_picks: Optional[int]\n    # ... etc\n</code></pre>"},{"location":"api/models/#using-models","title":"Using Models","text":"<pre><code>from opendota import OpenDota\n\nasync with OpenDota() as client:\n    # Access typed properties\n    match = await client.get_match(8461956309)\n    print(f\"Duration: {match.duration}s\")\n    print(f\"Winner: {'Radiant' if match.radiant_win else 'Dire'}\")\n\n    for player in match.players:\n        team = \"Radiant\" if player.player_slot &lt; 128 else \"Dire\"\n        print(f\"{team}: {player.kills}/{player.deaths}/{player.assists}\")\n</code></pre>"}]}