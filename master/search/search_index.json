{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Python OpenDota SDK","text":"\ud83e\udd16 AI Summary <p>Async Python SDK for OpenDota API. Use <code>OpenDota()</code> as async context manager. Key methods: <code>get_match(id)</code>, <code>get_player(id)</code>, <code>get_public_matches()</code>, <code>get_heroes()</code>. Returns Pydantic models by default (type-safe), or dicts with <code>format='json'</code>. Free tier: 2000 calls/day. Install: <code>pip install python-opendota-sdk</code>.</p> <p>Modern async Python wrapper for the OpenDota API</p> <p> </p> <p>A modern, async Python wrapper for the OpenDota API with full type safety and comprehensive coverage.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Async/await support - Built with <code>httpx</code> for modern async Python applications</li> <li>Type safety - Full type hints and Pydantic models for all API responses</li> <li>Comprehensive coverage - Support for matches, players, heroes, and more endpoints</li> <li>Rate limiting aware - Handles API rate limits gracefully with proper error handling</li> <li>Simple API - Clean, intuitive interface following Python best practices</li> <li>Well tested - Comprehensive test suite with real API integration tests</li> <li>Python 3.9+ - Compatible with modern Python versions</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import asyncio\nfrom opendota import OpenDota\n\nasync def main():\n    async with OpenDota() as client:\n        # Get recent public matches\n        matches = await client.get_public_matches()\n        print(f\"Found {len(matches)} recent matches\")\n\n        # Get detailed match data\n        match = await client.get_match(matches[0].match_id)\n        print(f\"Match duration: {match.duration // 60}m\")\n\n        # Get all heroes\n        heroes = await client.get_heroes()\n        print(f\"Total heroes: {len(heroes)}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install python-opendota-sdk\n</code></pre> <p>Or with uv:</p> <pre><code>uv add python-opendota-sdk\n</code></pre>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub Repository</li> <li>PyPI Package</li> <li>OpenDota API Docs</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"\ud83e\udd16 AI Summary <p>Version scheme: <code>{dota_major}.{dota_minor}.{dota_letter}.{sdk_release}</code> (e.g., 7.40.0 = Dota patch 7.40, initial SDK release). Current version adds: async httpx client, Pydantic models, matches/players/heroes/teams/leagues/pro_players endpoints, error handling, rate limiting, API key support, caching.</p> <p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#7401-2025-12-16","title":"[7.40.1] - 2025-12-16","text":""},{"location":"changelog/#added","title":"Added","text":""},{"location":"changelog/#new-match-fields","title":"New Match Fields","text":"<ul> <li>Team Information: <code>radiant_team_id</code>, <code>radiant_name</code>, <code>radiant_logo</code>, <code>radiant_captain</code>, <code>dire_team_id</code>, <code>dire_name</code>, <code>dire_logo</code>, <code>dire_captain</code>, <code>radiant_team_complete</code>, <code>dire_team_complete</code></li> <li>Team Objects: <code>radiant_team</code>, <code>dire_team</code> (embedded <code>MatchTeam</code> models)</li> <li>League Object: <code>league</code> (embedded <code>MatchLeague</code> model with <code>leagueid</code>, <code>name</code>, <code>tier</code>, <code>banner</code>)</li> <li>Draft Timing: <code>draft_timings</code> (list of <code>DraftTiming</code> with pick order, timing, hero selection)</li> <li>Match Analysis: <code>comeback</code>, <code>stomp</code>, <code>pre_game_duration</code>, <code>flags</code></li> <li>Chat: <code>chat</code> (list of <code>ChatMessage</code> with time, type, key, slot)</li> <li>Metadata: <code>pauses</code>, <code>metadata</code>, <code>od_data</code>, <code>cosmetics</code>, <code>all_word_counts</code>, <code>my_word_counts</code></li> </ul>"},{"location":"changelog/#new-player-fields-within-match","title":"New Player Fields (within Match)","text":"<ul> <li>Identity: <code>hero_variant</code>, <code>personaname</code>, <code>name</code>, <code>rank_tier</code>, <code>is_contributor</code>, <code>is_subscriber</code></li> <li>Items: <code>item_neutral2</code> (second neutral item slot)</li> <li>Team Context: <code>isRadiant</code>, <code>radiant_win</code>, <code>win</code>, <code>lose</code>, <code>team_number</code>, <code>team_slot</code></li> <li>Match Metadata: <code>duration</code>, <code>game_mode</code>, <code>lobby_type</code>, <code>cluster</code>, <code>patch</code>, <code>region</code>, <code>start_time</code></li> <li>Laning: <code>lane</code>, <code>lane_role</code>, <code>lane_kills</code>, <code>lane_efficiency</code>, <code>lane_efficiency_pct</code>, <code>is_roaming</code></li> <li>Party: <code>party_id</code>, <code>party_size</code></li> <li>Combat Stats: <code>kda</code>, <code>hero_kills</code>, <code>tower_kills</code>, <code>courier_kills</code>, <code>observer_kills</code>, <code>sentry_kills</code>, <code>roshan_kills</code>, <code>ancient_kills</code>, <code>neutral_kills</code>, <code>necronomicon_kills</code></li> <li>Ward Placement: <code>obs_placed</code>, <code>sen_placed</code>, <code>observers_placed</code>, <code>observer_uses</code>, <code>sentry_uses</code></li> <li>Economy: <code>total_gold</code>, <code>total_xp</code>, <code>kills_per_min</code>, <code>actions_per_min</code></li> <li>Farming: <code>camps_stacked</code>, <code>creeps_stacked</code>, <code>rune_pickups</code>, <code>buyback_count</code></li> <li>Teamfight: <code>teamfight_participation</code>, <code>stuns</code>, <code>firstblood_claimed</code></li> <li>Time Series: <code>gold_t</code>, <code>xp_t</code>, <code>lh_t</code>, <code>dn_t</code>, <code>times</code></li> <li>Detailed Breakdowns: <code>benchmarks</code>, <code>gold_reasons</code>, <code>xp_reasons</code>, <code>damage</code>, <code>damage_taken</code>, <code>damage_inflictor</code>, <code>damage_inflictor_received</code>, <code>damage_targets</code>, <code>hero_hits</code>, <code>ability_targets</code>, <code>ability_uses</code>, <code>ability_upgrades_arr</code>, <code>item_uses</code>, <code>item_usage</code>, <code>item_win</code>, <code>purchase</code>, <code>purchase_time</code>, <code>first_purchase_time</code>, <code>actions</code>, <code>killed</code>, <code>killed_by</code>, <code>kill_streaks</code>, <code>multi_kills</code>, <code>runes</code>, <code>healing</code>, <code>life_state</code>, <code>lane_pos</code>, <code>obs</code>, <code>sen</code>, <code>cosmetics</code>, <code>permanent_buffs</code>, <code>connection_log</code></li> <li>Logs: <code>kills_log</code>, <code>buyback_log</code>, <code>purchase_log</code>, <code>runes_log</code>, <code>obs_log</code>, <code>sen_log</code>, <code>obs_left_log</code>, <code>sen_left_log</code>, <code>neutral_item_history</code>, <code>neutral_tokens_log</code></li> </ul>"},{"location":"changelog/#new-models","title":"New Models","text":"<ul> <li><code>MatchTeam</code> - Team data within a match</li> <li><code>MatchLeague</code> - League information within a match</li> <li><code>DraftTiming</code> - Draft timing data for picks/bans</li> <li><code>ChatMessage</code> - Chat message structure</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li><code>computed_mmr</code> type changed from <code>int</code> to <code>float</code> (API returns decimals)</li> <li><code>last_login</code> type changed from <code>int</code> to <code>str</code> (API returns ISO datetime strings)</li> <li><code>cosmetics</code> type changed from <code>List[int]</code> to <code>List[Dict]</code> (API returns full item details)</li> <li><code>radiant_logo</code> and <code>dire_logo</code> types changed to <code>int</code> (API returns numeric IDs)</li> </ul>"},{"location":"changelog/#testing","title":"Testing","text":"<ul> <li>Added 29 new tests for new fields (78 total)</li> <li>Test coverage for pro matches (TI 2025) and public ranked matches</li> <li>Comparison tests between pro and public match data availability</li> </ul>"},{"location":"changelog/#73952-2025-12-15","title":"[7.39.5.2] - 2025-12-15","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Minor bug fixes and stability improvements</li> </ul>"},{"location":"changelog/#73951dev2-2025-12-03","title":"[7.39.5.1.dev2] - 2025-12-03","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Teams endpoints:</li> <li><code>get_teams()</code> - Get all teams sorted by rating</li> <li><code>get_team(team_id)</code> - Get team details</li> <li><code>get_team_players(team_id)</code> - Get team roster</li> <li><code>get_team_matches(team_id)</code> - Get team match history</li> <li>Pro Players endpoints:</li> <li><code>get_pro_players()</code> - Get all professional players</li> <li>Leagues endpoints:</li> <li><code>get_leagues()</code> - Get all leagues/tournaments</li> <li><code>get_league(league_id)</code> - Get league details</li> <li><code>get_league_matches(league_id)</code> - Get league matches</li> <li><code>get_league_teams(league_id)</code> - Get teams in a league</li> <li>New Pydantic models: <code>Team</code>, <code>TeamPlayer</code>, <code>TeamMatch</code>, <code>ProPlayer</code>, <code>League</code></li> <li>Comprehensive test suite for new endpoints</li> </ul>"},{"location":"changelog/#73951-2025-12-02","title":"[7.39.5.1] - 2025-12-02","text":"<p>Version scheme: <code>{dota_major}.{dota_minor}.{dota_letter}.{sdk_release}</code> - <code>7.39.5</code> = Dota 2 patch 7.39e (a=1, b=2, c=3, d=4, e=5) - <code>.1</code> = First SDK release for this patch</p>"},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Full async/await support with httpx</li> <li>Complete type safety with Pydantic models</li> <li>Matches endpoints:</li> <li><code>get_match()</code> - Get detailed match data</li> <li><code>get_public_matches()</code> - Get public matches with filters</li> <li><code>get_pro_matches()</code> - Get professional matches</li> <li><code>get_parsed_matches()</code> - Get parsed match data</li> <li>Players endpoints:</li> <li><code>get_player()</code> - Get player profile</li> <li><code>get_player_matches()</code> - Get player match history with extensive filtering</li> <li>Heroes endpoints:</li> <li><code>get_heroes()</code> - Get all heroes data</li> <li><code>get_hero_stats()</code> - Get hero statistics</li> <li>Comprehensive error handling with custom exceptions</li> <li>Rate limiting awareness and proper HTTP status handling</li> <li>Optional API key support for higher rate limits</li> <li>Context manager support for automatic cleanup</li> <li>Built-in response caching</li> <li>Extensive test suite with real API integration tests</li> <li>Full documentation with MkDocs Material theme</li> </ul>"},{"location":"changelog/#technical-details","title":"Technical Details","text":"<ul> <li>Python 3.9+ support</li> <li>Built with httpx for modern async HTTP</li> <li>Pydantic v2 for data validation and parsing</li> <li>Comprehensive type hints throughout</li> <li>CI/CD with GitHub Actions</li> <li>TestPyPI and PyPI publishing support</li> </ul>"},{"location":"examples/","title":"Examples","text":"\ud83e\udd16 AI Summary <p>Code examples for common tasks: Match analysis - get KDA, GPM, winner. Player tracking - profile, recent matches, winrate, most played heroes. Meta heroes - filter by pro pick rates, sort by win rate. Player comparison - compare stats between two players. Pro match monitor - poll for new pro matches. Batch collection - paginate through high MMR matches with rate limiting. New in 7.40: Draft analysis, support stats (wards, stacking), laning efficiency, gold/XP timelines, hero variants, comeback detection.</p>"},{"location":"examples/#analyze-match-performance","title":"Analyze Match Performance","text":"<pre><code>from opendota import OpenDota\n\nasync def analyze_match(match_id: int):\n    async with OpenDota() as client:\n        match = await client.get_match(match_id)\n\n        print(f\"Match {match_id} Analysis:\")\n        print(f\"Duration: {match.duration // 60}m {match.duration % 60}s\")\n        print(f\"Winner: {'Radiant' if match.radiant_win else 'Dire'}\")\n        print(f\"Score: {match.radiant_score} - {match.dire_score}\")\n\n        # Find MVP by KDA\n        best_kda = max(\n            match.players,\n            key=lambda p: (p.kills + p.assists) / max(p.deaths, 1)\n        )\n        team = \"Radiant\" if best_kda.player_slot &lt; 128 else \"Dire\"\n        print(f\"Best KDA: {best_kda.kills}/{best_kda.deaths}/{best_kda.assists} ({team})\")\n\n        # Team gold comparison\n        radiant_gpm = sum(p.gold_per_min for p in match.players if p.player_slot &lt; 128)\n        dire_gpm = sum(p.gold_per_min for p in match.players if p.player_slot &gt;= 128)\n        print(f\"Avg GPM - Radiant: {radiant_gpm/5:.0f}, Dire: {dire_gpm/5:.0f}\")\n</code></pre>"},{"location":"examples/#track-player-progress","title":"Track Player Progress","text":"<pre><code>from opendota import OpenDota\n\nasync def track_player(account_id: int):\n    async with OpenDota() as client:\n        # Get player profile\n        player = await client.get_player(account_id)\n        print(f\"Player: {player.profile.personaname}\")\n        print(f\"Rank: {player.rank_tier}\")\n\n        # Get recent matches\n        matches = await client.get_player_matches(account_id, limit=20)\n\n        wins = sum(1 for m in matches if (m.player_slot &lt; 128) == m.radiant_win)\n        total = len(matches)\n        winrate = wins / total * 100\n\n        avg_kills = sum(m.kills for m in matches) / total\n        avg_deaths = sum(m.deaths for m in matches) / total\n        avg_assists = sum(m.assists for m in matches) / total\n\n        print(f\"Last {total} matches:\")\n        print(f\"Winrate: {winrate:.1f}% ({wins}/{total})\")\n        print(f\"Avg KDA: {avg_kills:.1f}/{avg_deaths:.1f}/{avg_assists:.1f}\")\n\n        # Most played heroes\n        hero_counts = {}\n        for match in matches:\n            hero_counts[match.hero_id] = hero_counts.get(match.hero_id, 0) + 1\n\n        heroes = await client.get_heroes()\n        hero_names = {h.id: h.localized_name for h in heroes}\n\n        print(\"Most played heroes:\")\n        for hero_id, count in sorted(hero_counts.items(), key=lambda x: x[1], reverse=True)[:3]:\n            print(f\"  {hero_names.get(hero_id, 'Unknown')}: {count} games\")\n</code></pre>"},{"location":"examples/#find-meta-heroes","title":"Find Meta Heroes","text":"<pre><code>from opendota import OpenDota\n\nasync def find_meta_heroes():\n    async with OpenDota() as client:\n        hero_stats = await client.get_hero_stats()\n\n        # Filter heroes with significant pick rates\n        meta_heroes = [h for h in hero_stats if (h.pro_pick or 0) &gt; 50]\n\n        # Sort by win rate\n        meta_heroes.sort(\n            key=lambda h: (h.pro_win or 0) / max(h.pro_pick or 1, 1),\n            reverse=True\n        )\n\n        print(\"Current meta heroes (high pick + win rate):\")\n        for hero in meta_heroes[:10]:\n            if hero.pro_pick and hero.pro_win:\n                winrate = hero.pro_win / hero.pro_pick * 100\n                print(f\"{hero.localized_name}: {winrate:.1f}% WR ({hero.pro_pick} picks)\")\n</code></pre>"},{"location":"examples/#compare-two-players","title":"Compare Two Players","text":"<pre><code>from opendota import OpenDota\n\nasync def compare_players(player1_id: int, player2_id: int):\n    async with OpenDota() as client:\n        p1 = await client.get_player(player1_id)\n        p2 = await client.get_player(player2_id)\n\n        p1_matches = await client.get_player_matches(player1_id, limit=50)\n        p2_matches = await client.get_player_matches(player2_id, limit=50)\n\n        def calc_stats(matches):\n            wins = sum(1 for m in matches if (m.player_slot &lt; 128) == m.radiant_win)\n            avg_kda = sum(m.kills + m.assists for m in matches) / max(sum(m.deaths for m in matches), 1)\n            return {\"winrate\": wins / len(matches) * 100, \"kda\": avg_kda}\n\n        stats1 = calc_stats(p1_matches)\n        stats2 = calc_stats(p2_matches)\n\n        print(f\"Comparison: {p1.profile.personaname} vs {p2.profile.personaname}\")\n        print(f\"Winrate: {stats1['winrate']:.1f}% vs {stats2['winrate']:.1f}%\")\n        print(f\"Avg KDA: {stats1['kda']:.2f} vs {stats2['kda']:.2f}\")\n</code></pre>"},{"location":"examples/#pro-match-monitor","title":"Pro Match Monitor","text":"<pre><code>from opendota import OpenDota\nimport asyncio\n\nasync def monitor_pro_matches():\n    async with OpenDota() as client:\n        last_match_id = None\n\n        while True:\n            pro_matches = await client.get_pro_matches()\n\n            for match in pro_matches:\n                if last_match_id and match.match_id &lt;= last_match_id:\n                    break\n\n                if match.radiant_name and match.dire_name:\n                    winner = match.radiant_name if match.radiant_win else match.dire_name\n                    print(f\"[{match.league_name}] {match.radiant_name} vs {match.dire_name}\")\n                    print(f\"  Winner: {winner} ({match.duration // 60}m)\")\n\n            if pro_matches:\n                last_match_id = pro_matches[0].match_id\n\n            await asyncio.sleep(60)  # Check every minute\n</code></pre>"},{"location":"examples/#batch-data-collection","title":"Batch Data Collection","text":"<pre><code>from opendota import OpenDota\nimport asyncio\n\nasync def collect_high_mmr_matches(count: int = 100):\n    async with OpenDota() as client:\n        all_matches = []\n        last_match_id = None\n\n        while len(all_matches) &lt; count:\n            matches = await client.get_public_matches(\n                mmr_descending=6000,\n                less_than_match_id=last_match_id\n            )\n\n            if not matches:\n                break\n\n            all_matches.extend(matches)\n            last_match_id = matches[-1].match_id\n\n            # Respect rate limits\n            await asyncio.sleep(1)\n\n        print(f\"Collected {len(all_matches)} high MMR matches\")\n        return all_matches[:count]\n</code></pre>"},{"location":"examples/#analyze-pro-match-draft-new-in-740","title":"Analyze Pro Match Draft (New in 7.40)","text":"<pre><code>from opendota import OpenDota\n\nasync def analyze_draft(match_id: int):\n    async with OpenDota() as client:\n        match = await client.get_match(match_id)\n\n        if not match.draft_timings:\n            print(\"No draft data (not Captains Mode)\")\n            return\n\n        # Get hero names\n        heroes = await client.get_heroes()\n        hero_names = {h.id: h.localized_name for h in heroes}\n\n        print(f\"Draft: {match.radiant_name} vs {match.dire_name}\")\n        print(f\"Tournament: {match.league.name}\\n\")\n\n        bans = [d for d in match.draft_timings if not d.pick]\n        picks = [d for d in match.draft_timings if d.pick]\n\n        print(\"Bans:\")\n        for ban in bans:\n            team = match.radiant_name if ban.active_team == 0 else match.dire_name\n            hero = hero_names.get(ban.hero_id, \"Unknown\")\n            print(f\"  {team}: {hero}\")\n\n        print(\"\\nPicks:\")\n        for pick in picks:\n            team = match.radiant_name if pick.active_team == 0 else match.dire_name\n            hero = hero_names.get(pick.hero_id, \"Unknown\")\n            print(f\"  {team}: {hero}\")\n</code></pre>"},{"location":"examples/#support-player-analysis-new-in-740","title":"Support Player Analysis (New in 7.40)","text":"<pre><code>from opendota import OpenDota\n\nasync def analyze_supports(match_id: int):\n    async with OpenDota() as client:\n        match = await client.get_match(match_id)\n        heroes = await client.get_heroes()\n        hero_names = {h.id: h.localized_name for h in heroes}\n\n        print(f\"Support Analysis: {match.radiant_name} vs {match.dire_name}\\n\")\n\n        # Find supports by ward placement\n        supports = sorted(\n            match.players,\n            key=lambda p: (p.obs_placed or 0) + (p.sen_placed or 0),\n            reverse=True\n        )[:4]  # Top 4 ward placers\n\n        for player in supports:\n            team = \"Radiant\" if player.isRadiant else \"Dire\"\n            hero = hero_names.get(player.hero_id, \"Unknown\")\n\n            print(f\"[{team}] {player.personaname} - {hero}\")\n            print(f\"  Wards: {player.obs_placed or 0} obs, {player.sen_placed or 0} sen\")\n            print(f\"  Camps stacked: {player.camps_stacked or 0}\")\n            print(f\"  Teamfight: {(player.teamfight_participation or 0) * 100:.0f}%\")\n            print()\n</code></pre>"},{"location":"examples/#laning-phase-analysis-new-in-740","title":"Laning Phase Analysis (New in 7.40)","text":"<pre><code>from opendota import OpenDota\n\nasync def analyze_laning(match_id: int):\n    async with OpenDota() as client:\n        match = await client.get_match(match_id)\n        heroes = await client.get_heroes()\n        hero_names = {h.id: h.localized_name for h in heroes}\n\n        lane_names = {1: \"Safelane\", 2: \"Mid\", 3: \"Offlane\"}\n\n        print(\"Laning Phase Analysis\\n\")\n\n        for team_name, is_radiant in [(\"Radiant\", True), (\"Dire\", False)]:\n            print(f\"{team_name}:\")\n            team_players = [p for p in match.players if p.isRadiant == is_radiant]\n\n            for player in sorted(team_players, key=lambda p: p.lane or 0):\n                hero = hero_names.get(player.hero_id, \"Unknown\")\n                lane = lane_names.get(player.lane, \"Unknown\")\n                eff = (player.lane_efficiency or 0) * 100\n\n                print(f\"  {hero} ({lane}): {eff:.0f}% efficiency\")\n\n            print()\n</code></pre>"},{"location":"examples/#goldxp-timeline-new-in-740","title":"Gold/XP Timeline (New in 7.40)","text":"<pre><code>from opendota import OpenDota\n\nasync def plot_economy(match_id: int):\n    async with OpenDota() as client:\n        match = await client.get_match(match_id)\n\n        # Get carry players (highest GPM)\n        carries = sorted(match.players, key=lambda p: p.gold_per_min, reverse=True)[:2]\n\n        for player in carries:\n            if not player.gold_t:\n                continue\n\n            team = \"Radiant\" if player.isRadiant else \"Dire\"\n            print(f\"[{team}] {player.personaname}\")\n            print(f\"  Final gold: {player.gold_t[-1]:,}\")\n            print(f\"  10 min gold: {player.gold_t[10]:,}\")\n            print(f\"  20 min gold: {player.gold_t[20]:,}\")\n\n            # Calculate gold gained per phase\n            laning = player.gold_t[10] - player.gold_t[0]\n            mid = player.gold_t[20] - player.gold_t[10]\n            late = player.gold_t[-1] - player.gold_t[20]\n\n            print(f\"  Laning (0-10): +{laning:,}\")\n            print(f\"  Mid (10-20): +{mid:,}\")\n            print(f\"  Late (20+): +{late:,}\")\n            print()\n</code></pre>"},{"location":"examples/#hero-variant-tracking-new-in-740","title":"Hero Variant Tracking (New in 7.40)","text":"<pre><code>from opendota import OpenDota\n\nasync def find_arcana_games(hero_id: int, limit: int = 100):\n    \"\"\"Find recent games where players used hero personas/arcanas.\"\"\"\n    async with OpenDota() as client:\n        heroes = await client.get_heroes()\n        hero_name = next((h.localized_name for h in heroes if h.id == hero_id), \"Unknown\")\n\n        matches = await client.get_public_matches()\n        arcana_count = 0\n\n        for pub_match in matches[:limit]:\n            match = await client.get_match(pub_match.match_id)\n\n            for player in match.players:\n                if player.hero_id == hero_id and player.hero_variant and player.hero_variant &gt; 0:\n                    arcana_count += 1\n                    print(f\"Match {match.match_id}: {hero_name} variant {player.hero_variant}\")\n\n        print(f\"\\nFound {arcana_count} games with {hero_name} arcana/persona\")\n</code></pre>"},{"location":"examples/#match-comeback-detection-new-in-740","title":"Match Comeback Detection (New in 7.40)","text":"<pre><code>from opendota import OpenDota\n\nasync def find_comebacks():\n    async with OpenDota() as client:\n        pro_matches = await client.get_pro_matches()\n\n        comebacks = []\n        for pm in pro_matches[:20]:\n            match = await client.get_match(pm.match_id)\n\n            if match.comeback and match.comeback &gt; 1000:\n                comebacks.append({\n                    \"match_id\": match.match_id,\n                    \"teams\": f\"{match.radiant_name} vs {match.dire_name}\",\n                    \"comeback\": match.comeback,\n                    \"winner\": match.radiant_name if match.radiant_win else match.dire_name\n                })\n\n        print(\"Recent Comeback Games:\")\n        for game in sorted(comebacks, key=lambda x: x[\"comeback\"], reverse=True):\n            print(f\"  {game['teams']}\")\n            print(f\"    Comeback score: {game['comeback']:.0f}\")\n            print(f\"    Winner: {game['winner']}\")\n            print()\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"\ud83e\udd16 AI Summary <p>Install: <code>pip install python-opendota-sdk</code> or <code>uv add python-opendota-sdk</code>. Use async context manager: <code>async with OpenDota() as client</code>. Optional API key via env var <code>OPENDOTA_API_KEY</code> or constructor param for unlimited calls. Two output formats: <code>format='pydantic'</code> (default, type-safe) or <code>format='json'</code> (raw dicts).</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#from-pypi-recommended","title":"From PyPI (Recommended)","text":"<pre><code>pip install python-opendota-sdk\n</code></pre> <p>Or with uv:</p> <pre><code>uv add python-opendota-sdk\n</code></pre>"},{"location":"getting-started/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/DeepBlueCoding/python-opendota-sdk.git\ncd python-opendota-sdk\nuv sync\n</code></pre>"},{"location":"getting-started/#authentication","title":"Authentication","text":"<p>The OpenDota API supports optional API keys for higher rate limits.</p>"},{"location":"getting-started/#rate-limits","title":"Rate Limits","text":"Tier Daily Calls Per Minute Free 2,000 60 With API Key Unlimited Higher"},{"location":"getting-started/#setting-api-key","title":"Setting API Key","text":"<pre><code># Option 1: Environment variable\nimport os\nos.environ[\"OPENDOTA_API_KEY\"] = \"your-api-key\"\n\n# Option 2: Direct initialization\nfrom opendota import OpenDota\nclient = OpenDota(api_key=\"your-api-key\")\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#context-manager-recommended","title":"Context Manager (Recommended)","text":"<pre><code>from opendota import OpenDota\n\nasync with OpenDota() as client:\n    matches = await client.get_public_matches()\n    # Client automatically closed when exiting context\n</code></pre>"},{"location":"getting-started/#manual-management","title":"Manual Management","text":"<pre><code>from opendota import OpenDota\n\nclient = OpenDota()\ntry:\n    matches = await client.get_public_matches()\nfinally:\n    await client.close()\n</code></pre>"},{"location":"getting-started/#output-formats","title":"Output Formats","text":"<p>Choose between structured Pydantic models or raw JSON dictionaries:</p> <pre><code># Pydantic models (default) - Full type safety\nclient = OpenDota(format='pydantic')\nmatches = await client.get_public_matches()\nprint(matches[0].match_id)  # Type-safe access\n\n# JSON dictionaries - Direct API response\nclient = OpenDota(format='json')\nmatches = await client.get_public_matches()\nprint(matches[0]['match_id'])  # Dict access\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Check out the Examples for common use cases</li> <li>See the API Reference for all available methods</li> </ul>"},{"location":"api/client/","title":"Client Reference","text":"\ud83e\udd16 AI Summary <p>OpenDota class constructor: <code>api_key</code>, <code>timeout</code>, <code>format</code> ('pydantic'/'json'). Match methods: <code>get_match(id)</code>, <code>get_public_matches(mmr_ascending, less_than_match_id)</code>, <code>get_pro_matches()</code>. Player methods: <code>get_player(account_id)</code>, <code>get_player_matches(account_id, hero_id, limit, win)</code>. Hero methods: <code>get_heroes()</code>, <code>get_hero_stats()</code>. Teams: <code>get_teams()</code>, <code>get_team(id)</code>, <code>get_team_players(id)</code>, <code>get_team_matches(id)</code>. Leagues: <code>get_leagues()</code>, <code>get_league(id)</code>, <code>get_league_matches(id)</code>, <code>get_league_teams(id)</code>. Pro Players: <code>get_pro_players()</code>.</p>"},{"location":"api/client/#opendota-class","title":"OpenDota Class","text":"<p>The main client for interacting with the OpenDota API.</p> <pre><code>from opendota import OpenDota\n</code></pre>"},{"location":"api/client/#constructor","title":"Constructor","text":"<pre><code>OpenDota(\n    data_dir: Optional[str] = None,\n    api_key: Optional[str] = None,\n    delay: int = 3,\n    fantasy: Optional[Dict[str, float]] = None,\n    api_url: Optional[str] = None,\n    timeout: float = 30.0,\n    format: Literal['pydantic', 'json'] = 'pydantic',\n    auth_method: Literal['header', 'query'] = 'header'\n)\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>data_dir</code> <code>str</code> <code>~/dota2</code> Directory for caching API responses <code>api_key</code> <code>str</code> <code>None</code> OpenDota API key for higher rate limits <code>delay</code> <code>int</code> <code>3</code> Delay between requests (ignored with API key) <code>timeout</code> <code>float</code> <code>30.0</code> Request timeout in seconds <code>format</code> <code>str</code> <code>'pydantic'</code> Response format: <code>'pydantic'</code> or <code>'json'</code> <code>auth_method</code> <code>str</code> <code>'header'</code> Auth method: <code>'header'</code> or <code>'query'</code>"},{"location":"api/client/#match-methods","title":"Match Methods","text":""},{"location":"api/client/#get_match","title":"get_match","text":"<p>Get detailed match data by match ID.</p> <pre><code>match = await client.get_match(8461956309)\n</code></pre> <p>Parameters:</p> <ul> <li><code>match_id</code> (int): The match ID to retrieve</li> </ul> <p>Returns: <code>Match</code> model or dict</p>"},{"location":"api/client/#get_public_matches","title":"get_public_matches","text":"<p>Get recent public matches with optional filters.</p> <pre><code>matches = await client.get_public_matches(\n    mmr_ascending=4000,\n    less_than_match_id=8461956309\n)\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>mmr_ascending</code> <code>int</code> Return matches with avg MMR ascending from this <code>mmr_descending</code> <code>int</code> Return matches with avg MMR descending from this <code>less_than_match_id</code> <code>int</code> Return matches with ID lower than this <p>Returns: <code>List[PublicMatch]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#get_pro_matches","title":"get_pro_matches","text":"<p>Get professional matches.</p> <pre><code>pro_matches = await client.get_pro_matches()\n</code></pre> <p>Parameters:</p> <ul> <li><code>less_than_match_id</code> (int, optional): Return matches with ID lower than this</li> </ul> <p>Returns: <code>List[ProMatch]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#player-methods","title":"Player Methods","text":""},{"location":"api/client/#get_player","title":"get_player","text":"<p>Get player profile by account ID.</p> <pre><code>player = await client.get_player(70388657)\n</code></pre> <p>Parameters:</p> <ul> <li><code>account_id</code> (int): The player's account ID</li> </ul> <p>Returns: <code>PlayerProfile</code> model or dict</p>"},{"location":"api/client/#get_player_matches","title":"get_player_matches","text":"<p>Get matches for a player with extensive filtering.</p> <pre><code>matches = await client.get_player_matches(\n    account_id=70388657,\n    hero_id=14,  # Pudge\n    limit=10,\n    win=1  # Only wins\n)\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>account_id</code> <code>int</code> Player's account ID (required) <code>limit</code> <code>int</code> Number of matches to return <code>offset</code> <code>int</code> Number of matches to skip <code>win</code> <code>int</code> Filter by wins (0=loss, 1=win) <code>hero_id</code> <code>int</code> Filter by hero ID <code>game_mode</code> <code>int</code> Filter by game mode <code>lobby_type</code> <code>int</code> Filter by lobby type <code>date</code> <code>int</code> Filter by days since epoch <p>Returns: <code>List[PlayerMatch]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#hero-methods","title":"Hero Methods","text":""},{"location":"api/client/#get_heroes","title":"get_heroes","text":"<p>Get all heroes data.</p> <pre><code>heroes = await client.get_heroes()\n</code></pre> <p>Returns: <code>List[Hero]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#get_hero_stats","title":"get_hero_stats","text":"<p>Get hero statistics including pick/win rates.</p> <pre><code>hero_stats = await client.get_hero_stats()\n</code></pre> <p>Returns: <code>List[HeroStats]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#team-methods","title":"Team Methods","text":""},{"location":"api/client/#get_teams","title":"get_teams","text":"<p>Get all teams sorted by rating.</p> <pre><code>teams = await client.get_teams()\n</code></pre> <p>Returns: <code>List[Team]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#get_team","title":"get_team","text":"<p>Get team details by ID.</p> <pre><code>team = await client.get_team(8599101)  # Team Spirit\n</code></pre> <p>Parameters:</p> <ul> <li><code>team_id</code> (int): The team ID to retrieve</li> </ul> <p>Returns: <code>Team</code> model or dict</p>"},{"location":"api/client/#get_team_players","title":"get_team_players","text":"<p>Get team roster (current and past players).</p> <pre><code>players = await client.get_team_players(8599101)\n</code></pre> <p>Parameters:</p> <ul> <li><code>team_id</code> (int): The team ID</li> </ul> <p>Returns: <code>List[TeamPlayer]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#get_team_matches","title":"get_team_matches","text":"<p>Get team match history.</p> <pre><code>matches = await client.get_team_matches(8599101)\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>team_id</code> <code>int</code> The team ID (required) <code>limit</code> <code>int</code> Number of matches to return (optional) <p>Returns: <code>List[TeamMatch]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#league-methods","title":"League Methods","text":""},{"location":"api/client/#get_leagues","title":"get_leagues","text":"<p>Get all leagues/tournaments.</p> <pre><code>leagues = await client.get_leagues()\n</code></pre> <p>Returns: <code>List[League]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#get_league","title":"get_league","text":"<p>Get league details by ID.</p> <pre><code>league = await client.get_league(15728)  # The International\n</code></pre> <p>Parameters:</p> <ul> <li><code>league_id</code> (int): The league ID to retrieve</li> </ul> <p>Returns: <code>League</code> model or dict</p>"},{"location":"api/client/#get_league_matches","title":"get_league_matches","text":"<p>Get matches from a league.</p> <pre><code>matches = await client.get_league_matches(15728, limit=50)\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>league_id</code> <code>int</code> The league ID (required) <code>limit</code> <code>int</code> Number of matches to return (optional) <p>Returns: <code>List[LeagueMatch]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#get_league_teams","title":"get_league_teams","text":"<p>Get teams participating in a league.</p> <pre><code>teams = await client.get_league_teams(15728)\n</code></pre> <p>Parameters:</p> <ul> <li><code>league_id</code> (int): The league ID</li> </ul> <p>Returns: <code>List[LeagueTeam]</code> or <code>List[dict]</code></p>"},{"location":"api/client/#pro-player-methods","title":"Pro Player Methods","text":""},{"location":"api/client/#get_pro_players","title":"get_pro_players","text":"<p>Get all professional players.</p> <pre><code>pro_players = await client.get_pro_players()\n</code></pre> <p>Returns: <code>List[ProPlayer]</code> or <code>List[dict]</code></p>"},{"location":"api/exceptions/","title":"Exceptions","text":"\ud83e\udd16 AI Summary <p>Exception hierarchy: <code>OpenDotaError</code> (base) \u2192 <code>OpenDotaAPIError</code> (has <code>status_code</code>) \u2192 <code>OpenDotaRateLimitError</code> (429), <code>OpenDotaNotFoundError</code> (404). Catch specific exceptions first, fallback to <code>OpenDotaAPIError</code>. For rate limits, implement exponential backoff retry (2^attempt seconds).</p> <p>Custom exceptions for handling API errors.</p>"},{"location":"api/exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>OpenDotaError (base)\n\u2514\u2500\u2500 OpenDotaAPIError\n    \u251c\u2500\u2500 OpenDotaRateLimitError\n    \u2514\u2500\u2500 OpenDotaNotFoundError\n</code></pre>"},{"location":"api/exceptions/#opendotaerror","title":"OpenDotaError","text":"<p>Base exception for all OpenDota SDK errors.</p> <pre><code>class OpenDotaError(Exception):\n    \"\"\"Base exception for OpenDota API errors.\"\"\"\n    pass\n</code></pre>"},{"location":"api/exceptions/#opendotaapierror","title":"OpenDotaAPIError","text":"<p>General API error with status code.</p> <pre><code>class OpenDotaAPIError(OpenDotaError):\n    def __init__(self, message: str, status_code: int):\n        self.status_code = status_code\n        super().__init__(message)\n</code></pre> <p>Attributes:</p> <ul> <li><code>status_code</code> (int): HTTP status code from the API</li> </ul>"},{"location":"api/exceptions/#opendotaratelimiterror","title":"OpenDotaRateLimitError","text":"<p>Raised when API rate limit is exceeded (HTTP 429).</p> <pre><code>class OpenDotaRateLimitError(OpenDotaAPIError):\n    \"\"\"Rate limit exceeded error.\"\"\"\n    pass\n</code></pre>"},{"location":"api/exceptions/#opendotanotfounderror","title":"OpenDotaNotFoundError","text":"<p>Raised when a resource is not found (HTTP 404).</p> <pre><code>class OpenDotaNotFoundError(OpenDotaAPIError):\n    \"\"\"Resource not found error.\"\"\"\n    pass\n</code></pre>"},{"location":"api/exceptions/#error-handling-example","title":"Error Handling Example","text":"<pre><code>from opendota import OpenDota\nfrom opendota.exceptions import (\n    OpenDotaAPIError,\n    OpenDotaNotFoundError,\n    OpenDotaRateLimitError\n)\n\nasync with OpenDota() as client:\n    try:\n        match = await client.get_match(invalid_match_id)\n    except OpenDotaNotFoundError:\n        print(\"Match not found\")\n    except OpenDotaRateLimitError:\n        print(\"Rate limit exceeded - wait before retrying\")\n    except OpenDotaAPIError as e:\n        print(f\"API error (status {e.status_code}): {e}\")\n</code></pre>"},{"location":"api/exceptions/#retry-strategy","title":"Retry Strategy","text":"<p>For rate limit errors, implement exponential backoff:</p> <pre><code>import asyncio\nfrom opendota.exceptions import OpenDotaRateLimitError\n\nasync def get_match_with_retry(client, match_id, max_retries=3):\n    for attempt in range(max_retries):\n        try:\n            return await client.get_match(match_id)\n        except OpenDotaRateLimitError:\n            if attempt &lt; max_retries - 1:\n                wait_time = 2 ** attempt  # 1, 2, 4 seconds\n                await asyncio.sleep(wait_time)\n            else:\n                raise\n</code></pre>"},{"location":"api/models/","title":"Data Models","text":"\ud83e\udd16 AI Summary <p>Pydantic models for API responses. Match models: <code>Match</code> (full data with players, teams, league, draft), <code>PublicMatch</code> (summary with avg_mmr), <code>ProMatch</code> (with team/league names). Player models: <code>PlayerProfile</code> (profile + rank_tier), <code>PlayerMatch</code> (hero_id, KDA, player_slot), <code>Player</code> (detailed match player with laning, combat, economy data). Hero models: <code>Hero</code> (name, roles, primary_attr), <code>HeroStats</code> (pro_pick/win/ban, rank-specific picks). New in 7.40: Team objects, league objects, draft timings, chat messages, detailed player analytics.</p> <p>All API responses are parsed into Pydantic models with full type safety.</p>"},{"location":"api/models/#match-models","title":"Match Models","text":""},{"location":"api/models/#match","title":"Match","text":"<p>Detailed match data returned by <code>get_match()</code>.</p> <pre><code>class Match(BaseModel):\n    match_id: int\n    duration: int\n    radiant_win: bool\n    radiant_score: int\n    dire_score: int\n    players: List[Player]\n\n    # Team information (pro matches)\n    radiant_team_id: Optional[int]\n    radiant_name: Optional[str]\n    dire_team_id: Optional[int]\n    dire_name: Optional[str]\n    radiant_team: Optional[MatchTeam]\n    dire_team: Optional[MatchTeam]\n\n    # League information\n    league: Optional[MatchLeague]\n\n    # Draft (Captains Mode)\n    draft_timings: Optional[List[DraftTiming]]\n\n    # Analysis\n    comeback: Optional[float]\n    stomp: Optional[float]\n\n    # Chat\n    chat: Optional[List[ChatMessage]]\n</code></pre> <p>Core Fields:</p> Field Type Description <code>match_id</code> <code>int</code> Unique match identifier <code>duration</code> <code>int</code> Match duration in seconds <code>radiant_win</code> <code>bool</code> Whether Radiant won <code>radiant_score</code> <code>int</code> Radiant kill score <code>dire_score</code> <code>int</code> Dire kill score <code>players</code> <code>List[Player]</code> List of player data <code>game_mode</code> <code>int</code> Game mode ID <code>lobby_type</code> <code>int</code> Lobby type ID <p>Team Fields (Pro Matches):</p> Field Type Description <code>radiant_team_id</code> <code>Optional[int]</code> Radiant team ID <code>radiant_name</code> <code>Optional[str]</code> Radiant team name <code>radiant_logo</code> <code>Optional[int]</code> Radiant team logo ID <code>radiant_captain</code> <code>Optional[int]</code> Radiant captain account ID <code>dire_team_id</code> <code>Optional[int]</code> Dire team ID <code>dire_name</code> <code>Optional[str]</code> Dire team name <code>dire_logo</code> <code>Optional[int]</code> Dire team logo ID <code>dire_captain</code> <code>Optional[int]</code> Dire captain account ID <p>Match Analysis Fields:</p> Field Type Description <code>comeback</code> <code>Optional[float]</code> Comeback indicator score <code>stomp</code> <code>Optional[float]</code> Stomp indicator score <code>pre_game_duration</code> <code>Optional[int]</code> Pre-game phase duration <code>flags</code> <code>Optional[int]</code> Match flags"},{"location":"api/models/#matchteam","title":"MatchTeam","text":"<p>Team data embedded within a match.</p> <pre><code>class MatchTeam(BaseModel):\n    team_id: Optional[int]\n    name: Optional[str]\n    tag: Optional[str]\n    logo_url: Optional[str]\n</code></pre>"},{"location":"api/models/#matchleague","title":"MatchLeague","text":"<p>League information embedded within a match.</p> <pre><code>class MatchLeague(BaseModel):\n    leagueid: int\n    name: Optional[str]\n    tier: Optional[str]  # \"premium\", \"professional\", \"amateur\"\n    banner: Optional[str]\n</code></pre>"},{"location":"api/models/#drafttiming","title":"DraftTiming","text":"<p>Draft timing data for each pick/ban in Captains Mode.</p> <pre><code>class DraftTiming(BaseModel):\n    order: int              # Draft order (0-23)\n    pick: bool              # True if pick, False if ban\n    active_team: int        # Team making the selection\n    hero_id: int            # Hero selected\n    player_slot: Optional[int]\n    extra_time: Optional[int]\n    total_time_taken: Optional[int]\n</code></pre>"},{"location":"api/models/#chatmessage","title":"ChatMessage","text":"<p>Chat message in a match.</p> <pre><code>class ChatMessage(BaseModel):\n    time: int               # Game time in seconds\n    type: Optional[str]     # Message type\n    key: Optional[str]      # Chat wheel key or message\n    slot: Optional[int]     # Player slot\n    player_slot: Optional[int]\n</code></pre>"},{"location":"api/models/#player-match-player","title":"Player (Match Player)","text":"<p>Detailed player data within a match. Contains extensive analytics for parsed matches.</p> <pre><code>class Player(BaseModel):\n    # Core stats\n    account_id: Optional[int]\n    player_slot: int\n    hero_id: int\n    kills: int\n    deaths: int\n    assists: int\n\n    # New identity fields\n    hero_variant: Optional[int]     # Hero persona/arcana variant\n    personaname: Optional[str]      # Display name\n    isRadiant: Optional[bool]       # Team indicator\n\n    # Items\n    item_0: Optional[int]\n    item_1: Optional[int]\n    # ... item_2 through item_5\n    item_neutral: Optional[int]     # First neutral item\n    item_neutral2: Optional[int]    # Second neutral item (new)\n\n    # Laning\n    lane: Optional[int]             # 1=safe, 2=mid, 3=off\n    lane_role: Optional[int]        # Lane role\n    lane_efficiency: Optional[float]\n    is_roaming: Optional[bool]\n\n    # Combat\n    kda: Optional[float]            # Calculated KDA ratio\n    tower_kills: Optional[int]\n    teamfight_participation: Optional[float]\n    stuns: Optional[float]\n\n    # Support stats\n    obs_placed: Optional[int]       # Observer wards placed\n    sen_placed: Optional[int]       # Sentry wards placed\n    camps_stacked: Optional[int]\n\n    # Time series (parsed matches)\n    gold_t: Optional[List[int]]     # Gold per minute\n    xp_t: Optional[List[int]]       # XP per minute\n    lh_t: Optional[List[int]]       # Last hits per minute\n\n    # Detailed breakdowns\n    benchmarks: Optional[Dict]      # Performance benchmarks\n    ability_uses: Optional[Dict]    # Ability usage counts\n    damage: Optional[Dict]          # Damage dealt breakdown\n</code></pre> <p>Identity Fields:</p> Field Type Description <code>hero_variant</code> <code>Optional[int]</code> Hero persona/arcana variant <code>personaname</code> <code>Optional[str]</code> Player display name <code>name</code> <code>Optional[str]</code> Pro player name <code>isRadiant</code> <code>Optional[bool]</code> True if on Radiant team <code>rank_tier</code> <code>Optional[int]</code> Player rank tier <p>Laning Fields:</p> Field Type Description <code>lane</code> <code>Optional[int]</code> Lane (1=safe, 2=mid, 3=off) <code>lane_role</code> <code>Optional[int]</code> Role in lane <code>lane_efficiency</code> <code>Optional[float]</code> Laning efficiency (0-1) <code>lane_kills</code> <code>Optional[int]</code> Kills during laning <code>is_roaming</code> <code>Optional[bool]</code> Roaming indicator <p>Combat Fields:</p> Field Type Description <code>kda</code> <code>Optional[float]</code> KDA ratio <code>hero_kills</code> <code>Optional[int]</code> Hero kills <code>tower_kills</code> <code>Optional[int]</code> Tower kills <code>roshan_kills</code> <code>Optional[int]</code> Roshan kills <code>teamfight_participation</code> <code>Optional[float]</code> Teamfight participation (0-1) <code>stuns</code> <code>Optional[float]</code> Stun duration dealt <p>Support Fields:</p> Field Type Description <code>obs_placed</code> <code>Optional[int]</code> Observer wards placed <code>sen_placed</code> <code>Optional[int]</code> Sentry wards placed <code>camps_stacked</code> <code>Optional[int]</code> Camps stacked <code>rune_pickups</code> <code>Optional[int]</code> Runes picked up"},{"location":"api/models/#publicmatch","title":"PublicMatch","text":"<p>Summary data for public matches.</p> <pre><code>class PublicMatch(BaseModel):\n    match_id: int\n    duration: int\n    radiant_win: bool\n    avg_mmr: Optional[int]\n    avg_rank_tier: Optional[float]\n    game_mode: int\n    lobby_type: int\n</code></pre>"},{"location":"api/models/#promatch","title":"ProMatch","text":"<p>Professional match data.</p> <pre><code>class ProMatch(BaseModel):\n    match_id: int\n    duration: int\n    radiant_win: bool\n    radiant_name: Optional[str]\n    dire_name: Optional[str]\n    radiant_team_id: Optional[int]\n    dire_team_id: Optional[int]\n    league_name: Optional[str]\n    leagueid: Optional[int]\n</code></pre>"},{"location":"api/models/#player-models","title":"Player Models","text":""},{"location":"api/models/#playerprofile","title":"PlayerProfile","text":"<p>Player profile and ranking data.</p> <pre><code>class PlayerProfile(BaseModel):\n    profile: Profile\n    rank_tier: Optional[int]\n    leaderboard_rank: Optional[int]\n</code></pre> <p>Profile Sub-model:</p> <pre><code>class Profile(BaseModel):\n    account_id: int\n    personaname: Optional[str]\n    name: Optional[str]\n    steamid: Optional[str]\n    avatar: Optional[str]\n    loccountrycode: Optional[str]\n    plus: Optional[bool]           # Dota Plus subscriber\n    is_contributor: Optional[bool]\n    is_subscriber: Optional[bool]\n</code></pre>"},{"location":"api/models/#playermatch","title":"PlayerMatch","text":"<p>Match data from player's perspective (player match history).</p> <pre><code>class PlayerMatch(BaseModel):\n    match_id: int\n    hero_id: int\n    kills: int\n    deaths: int\n    assists: int\n    player_slot: int\n    radiant_win: bool\n    duration: int\n    game_mode: int\n    hero_variant: Optional[int]    # New in 7.40\n</code></pre>"},{"location":"api/models/#hero-models","title":"Hero Models","text":""},{"location":"api/models/#hero","title":"Hero","text":"<p>Basic hero information.</p> <pre><code>class Hero(BaseModel):\n    id: int\n    name: str                      # Internal name (e.g., \"npc_dota_hero_antimage\")\n    localized_name: str            # Display name (e.g., \"Anti-Mage\")\n    primary_attr: str              # \"agi\", \"str\", \"int\", \"all\"\n    attack_type: str               # \"Melee\" or \"Ranged\"\n    roles: List[str]               # [\"Carry\", \"Escape\", \"Nuker\"]\n</code></pre>"},{"location":"api/models/#herostats","title":"HeroStats","text":"<p>Hero statistics with pick/win rates across skill brackets.</p> <pre><code>class HeroStats(BaseModel):\n    id: int\n    localized_name: str\n    pro_pick: Optional[int]\n    pro_win: Optional[int]\n    pro_ban: Optional[int]\n    pub_pick: Optional[int]\n    pub_win: Optional[int]\n    # Per-rank stats (1-8)\n    field_1_pick: Optional[int]    # Herald picks\n    field_1_win: Optional[int]     # Herald wins\n    # ... through field_8_pick/win (Immortal)\n    pub_pick_trend: Optional[List[int]]\n    pub_win_trend: Optional[List[int]]\n</code></pre>"},{"location":"api/models/#usage-examples","title":"Usage Examples","text":""},{"location":"api/models/#basic-match-analysis","title":"Basic Match Analysis","text":"<pre><code>from opendota import OpenDota\n\nasync with OpenDota() as client:\n    match = await client.get_match(8461956309)\n\n    # Access basic properties\n    print(f\"Duration: {match.duration}s\")\n    print(f\"Winner: {'Radiant' if match.radiant_win else 'Dire'}\")\n\n    # Access team info (pro matches)\n    if match.radiant_name:\n        print(f\"Teams: {match.radiant_name} vs {match.dire_name}\")\n\n    # Access league info\n    if match.league:\n        print(f\"Tournament: {match.league.name} ({match.league.tier})\")\n</code></pre>"},{"location":"api/models/#detailed-player-analysis","title":"Detailed Player Analysis","text":"<pre><code>async with OpenDota() as client:\n    match = await client.get_match(8461956309)\n\n    for player in match.players:\n        team = \"Radiant\" if player.isRadiant else \"Dire\"\n        print(f\"[{team}] {player.personaname}\")\n        print(f\"  Hero variant: {player.hero_variant}\")\n        print(f\"  KDA: {player.kda:.2f}\")\n        print(f\"  Lane: {player.lane}, Efficiency: {player.lane_efficiency:.1%}\")\n\n        if player.obs_placed:\n            print(f\"  Wards: {player.obs_placed} obs, {player.sen_placed} sen\")\n\n        if player.gold_t:\n            print(f\"  Final gold: {player.gold_t[-1]}\")\n</code></pre>"},{"location":"api/models/#draft-analysis","title":"Draft Analysis","text":"<pre><code>async with OpenDota() as client:\n    match = await client.get_match(8461956309)\n\n    if match.draft_timings:\n        print(\"Draft order:\")\n        for draft in match.draft_timings:\n            action = \"PICK\" if draft.pick else \"BAN\"\n            team = \"Radiant\" if draft.active_team == 0 else \"Dire\"\n            print(f\"  {draft.order}: [{team}] {action} hero {draft.hero_id}\")\n</code></pre>"},{"location":"api/models/#pro-vs-public-match-data","title":"Pro vs Public Match Data","text":"<pre><code>async with OpenDota() as client:\n    # Pro match - has team/league/draft data\n    pro = await client.get_match(8461956309)\n    print(f\"Pro match: {pro.radiant_name} vs {pro.dire_name}\")\n    print(f\"League: {pro.league.name}\")\n    print(f\"Draft entries: {len(pro.draft_timings)}\")\n\n    # Public match - limited metadata\n    pub = await client.get_match(8607246638)\n    print(f\"Public match: Team info = {pub.radiant_name}\")  # None\n    print(f\"League: {pub.league}\")  # None\n    print(f\"Draft: {pub.draft_timings}\")  # None or empty\n</code></pre>"}]}